//oops is a proograming style which revols around objects
//object is a entity which has state/property and behavior

//class is user defiend data type; for ex. hero rahim, here rahim is variable name and hero is its data type (user defined, not inbuild)
//object is a instance of class


//access modifiers:
//private (default), public, protected
 
//
#include <iostream>
#include "0test.cpp"
using namespace std;


//using initialization list here, will be discussed in the upcoming slide
class demo{
public:
    int a, b;
    demo(int i, int j) : a (i), b(87 - j){
        cout << "constructor called" << endl;
        cout << a << ' ' << b << endl;
    }
} obj1(3, 7);   //declaring object here
//this is a valid syntex



class hero{
    private:
    int roll;
    // char name[49];
    int check;
    void private_func(){
        cout << "I'm private function" << endl;
        cout << check << endl;
    }

    public: // by default these properties are private..means they can't be accssed from main function
    //properties/ data member
    int health;
    char level;

    hero(int n) : check(n){};    //constructor : initialized check with n;
    hero(){};   //i needed to create a default constrctor, cuz as soon as i wrote the above line(param. constructor), the default constructor that was auto generated by compiler was gone

    void public_func(){
        cout << "Public" << endl;
        private_func();
    }

    void print(){
        cout << roll << endl;  //private property can only be accessed in the class
    }

    //getter and setter (accessing private in main)
    // void setRoll(int h){     //comment out; cuz i want to implement this function outside of this class
    //     roll = h;
    // }
    void setRoll(int h);    //declaring first; when compiler reach here, it will try to find this function's implementation

    void setRollNew(int h, char password){
        if(password == 'A')
            roll = h;
        }
 
    int getRoll(){
        return roll;
    }
};

void hero::setRoll(int h){
    roll = h;
}

int main(){
    //creation of object
    hero rahim; //hero type object

    hero exam(55);
    exam.public_func();

    rahim.health = 89;
    rahim.level = 'a';

    cout << "size: " << sizeof(rahim) << endl;  //should 12 size. why? bcoz of padding..padding refers to the extra bytes added by the compiler to align data structures in memory. This is done for performance and alignment considerations, as many computer architectures have alignment requirements for data types. For example, a struct or a class in C++ may have some extra bytes added to align its members in a way that is efficient for the underlying hardware. Padding can affect the size of data structures and how data is stored in memory, and it's essential to consider when working with binary data or when memory layout matters.
    //if the class is empty then size will be 1 (to have the track of the class)

    newx y; //declared in another file
    cout << "hero health: " <<rahim.health << endl;
    cout << "hero level: " << rahim.level << endl;



    //getter and setter
    hero aleen;
    aleen.setRoll(3);
    cout << aleen.getRoll() << endl;

    aleen.setRollNew(5, 'b');   //wrong passward
    cout << aleen.getRoll() << endl;

    aleen.setRollNew(5, 'A');
    cout << aleen.getRoll() << endl;

    cout << obj1.a << " " << obj1.b << endl;

    return 0;
}

/*

class hero(){
    int a;
    char name;
}

hero h1;
why sizeof h1 is 8 instead of 5??


ans:
The size of the hero class instance h1 is not 5 because of padding added by the compiler for alignment purposes. 
In your hero class, you have an int member (a) which typically requires alignment to 4 bytes (on most systems), and a char member (name).
On many systems, the size of a char is 1 byte, and the size of an int is typically 4 bytes. However, the compiler often adds padding between members of a class or 
structure to ensure that each member is aligned to an address that is a multiple of its size. This is done for efficiency reasons, as accessing properly aligned memory can be more efficient on some architectures.
So, in your case, even though you might expect the size to be 5 bytes (1 byte for char + 4 bytes for int), the compiler adds 3 bytes of padding after the char name member to ensure that the int a member is properly aligned. 
Hence, the total size becomes 8 bytes.
*/


/*
greedy alignment:
struct Example {
    char a;
    int b;
};

In this case, char typically requires alignment of 1 byte, while int usually requires alignment of 4 bytes (on many systems). 
A greedy alignment strategy would align the int member on a boundary that satisfies its alignment requirement, even if it means leaving unused space after the char member.

So, the structure might be laid out like this:
| a | unused | b | b | b | b |
Here, a is aligned on a 1-byte boundary, and b starts at an address that is a multiple of 4 bytes, satisfying the alignment requirement for int.

Greedy alignment can lead to less memory-efficient data structures, as it may introduce padding between members to ensure proper alignment. However, it's often used for performance reasons, 
as accessing properly aligned data can be more efficient, especially on some architectures.
*/

